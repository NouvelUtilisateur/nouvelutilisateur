io.stdout:setvbuf('no')
love.math.setRandomSeed(love.timer.getTime()) -- à utiliser avec love.math.random(nb1,nb2) --
love.graphics.setDefaultFilter("nearest")
-------------------------------------------- COLLISIONS RESOLVED UP RIGHT DOWN LEFT --------------------------------------------
ball = {}
	ball.x = 0
	ball.y = 0
	ball.width = 50
	ball.height = 50
	ball.oldx = nil
	ball.oldy = nil
	ball.oldxwidth = nil
	ball.oldyheight = nil
	ball.vx = 400
	ball.vy = 400

wall = {}
	wall.x = 250
	wall.y = 200
	wall.width = 200
	wall.height = 200
	wall.oldx = nil
	wall.oldy = nil


function love.load()

end


function love.update(dt)
	oldBallPosition() -- appelle la fonction pour sauvegarder les positions de la balle
	oldWallPosition() -- non utilisé
	
	updateBall(dt)
	if chekCollision(ball, wall) then -- verifie s'il y a collision
		print(resolveCollision(ball, wall)) -- detecte si la balle tape en haut/bas/gauche/droite et inverse la velocité en fonction
	end
	
	
end


function love.draw()
	love.graphics.rectangle("fill", ball.x, ball.y, ball.width, ball.height)
	love.graphics.rectangle("line", wall.x, wall.y, wall.width, wall.height)
end	


function oldBallPosition() -- sauvegarde les anciens x et y de la ball
	ball.oldx = ball.x
	ball.oldy = ball.y
end	
function oldWallPosition() -- sauvegarde les anciens x et y du mur (finalement non utilisé dans cet algo mais util si on fait un objet qui se déplace)
	wall.oldx = wall.x
	wall.oldy = wall.y
end

function updateBall(dt) -- fait avancer la balle automatiquement et collisionne avec les murs
	ball.x = ball.x + ball.vx * dt
	ball.y = ball.y + ball.vy * dt
	if ball.x < 0 then 
		ball.x = 0
		ball.vx = - ball.vx
	elseif ball.y < 0 then
		ball.y = 0
		ball.vy = - ball.vy
	elseif ball.x + ball.width > love.graphics.getWidth() then
		ball.x = love.graphics.getWidth() - ball.width
		ball.vx = - ball.vx
	elseif ball.y + ball.height > love.graphics.getHeight() then
		ball.y = love.graphics.getHeight() - ball.height
		ball.vy = - ball.vy
	end 
	--[[
	if love.keyboard.isDown("d") then
		ball.x = ball.x + ball.vx * dt
	end
	if love.keyboard.isDown("q") then
		ball.x = ball.x - ball.vx * dt
	end
	if love.keyboard.isDown("z") then
		ball.y = ball.y - ball.vy * dt
	end
	if love.keyboard.isDown("s") then
		ball.y = ball.y + ball.vy * dt
	end
	]]
end

function chekCollision(box1, box2) -- detecte s'il n'y a pas de collision, renvoie vrai s'il y a collision
   if (box2.x > box1.x + box1.width)  -- trop à droite donc aucune collision
	or (box2.x + box2.width < box1.x) -- trop à gauche ""
	or (box2.y > box1.y + box1.height) -- trop en bas ""
	or (box2.y + box2.height < box1.y) then  -- trop en haut ""
          return false 
   else
          return true                
    end
end

function resolveCollision(box1, box2) -- (pushback = self.x + self.width - e.x) detecte si la balle tape en haut/bas/gauche/droite du mur si oui, inverse la velocité
	if box1.oldx + box1.width < box2.x then 
		box1.x = box1.x - ((box1.x + box1.width) - box2.x) - 0.1
		ball.vx = - ball.vx
		return "collideLeft"
	elseif box1.oldx > box2.x + box2.width then 
		box1.x = box1.x - (box1.x - (box2.x + box2.width)) + 0.1
		ball.vx = - ball.vx
		return "collideRight"
	elseif box1.oldy + box1.height < box2.y then 
		box1.y = box1.y - ((box1.y + box1.height) - box2.y) - 0.1
		ball.vy = - ball.vy
		return "collideOver"
	elseif box1.oldy > box2.y + box2.height then 
		box1.y = box1.y - (box1.y - (box2.y + box2.height)) + 0.1
		ball.vy = - ball.vy
		return "collideUnderneath"
	end
end


